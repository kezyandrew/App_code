import { IonicNativePlugin } from '@ionic-native/core';
import * as ɵngcc0 from '@angular/core';
export interface FileUploadOptions {
    /**
     * The name of the form element.
     * Defaults to 'file'.
     */
    fileKey?: string;
    /**
     * The file name to use when saving the file on the server.
     * Defaults to 'image.jpg'.
     */
    fileName?: string;
    /**
     * The HTTP method to use - either PUT or POST.
     * Defaults to POST.
     */
    httpMethod?: string;
    /**
     * The mime type of the data to upload.
     * Defaults to image/jpeg.
     */
    mimeType?: string;
    /**
     * A set of optional key/value pairs to pass in the HTTP request.
     */
    params?: {
        [s: string]: any;
    };
    /**
     * Whether to upload the data in chunked streaming mode.
     * Defaults to true.
     */
    chunkedMode?: boolean;
    /**
     * A map of header name/header values. Use an array to specify more
     * than one value. On iOS, FireOS, and Android, if a header named
     * Content-Type is present, multipart form data will NOT be used.
     */
    headers?: {
        [s: string]: any;
    };
}
export interface FileUploadResult {
    /**
     * The number of bytes sent to the server as part of the upload.
     */
    bytesSent: number;
    /**
     * The HTTP response code returned by the server.
     */
    responseCode: number;
    /**
     * The HTTP response returned by the server.
     */
    response: string;
    /**
     * The HTTP response headers by the server.
     */
    headers: {
        [s: string]: any;
    };
}
export interface FileTransferError {
    /**
     * One of the predefined error codes listed below.
     */
    code: number;
    /**
     * URL to the source.
     */
    source: string;
    /**
     * URL to the target.
     */
    target: string;
    /**
     * HTTP status code. This attribute is only available when a response
     * code is received from the HTTP connection.
     */
    http_status: number;
    /**
     * Response body. This attribute is only available when a response is received from the HTTP connection.
     */
    body: string;
    /**
     * Either e.getMessage or e.toString.
     */
    exception: string;
}
/**
 * @name File Transfer
 *
 * @description
 * This plugin allows you to upload and download files.
 *
 * @deprecated
 * This plugin has been deprecated in favor of XHR2
 * https://cordova.apache.org/blog/2017/10/18/from-filetransfer-to-xhr2.html
 *
 * @usage
 * ```typescript
 * import { FileTransfer, FileUploadOptions, FileTransferObject } from '@ionic-native/file-transfer/ngx';
 * import { File } from '@ionic-native/file';
 *
 * constructor(private transfer: FileTransfer, private file: File) { }
 *
 * ...
 *
 * const fileTransfer: FileTransferObject = this.transfer.create();
 *
 * // Upload a file:
 * fileTransfer.upload(..).then(..).catch(..);
 *
 * // Download a file:
 * fileTransfer.download(..).then(..).catch(..);
 *
 * // Abort active transfer:
 * fileTransfer.abort();
 *
 * // full example
 * upload() {
 *   let options: FileUploadOptions = {
 *      fileKey: 'file',
 *      fileName: 'name.jpg',
 *      headers: {}
 *      .....
 *   }
 *
 *   fileTransfer.upload('<file path>', '<api endpoint>', options)
 *    .then((data) => {
 *      // success
 *    }, (err) => {
 *      // error
 *    })
 * }
 *
 * download() {
 *   const url = 'http://www.example.com/file.pdf';
 *   fileTransfer.download(url, this.file.dataDirectory + 'file.pdf').then((entry) => {
 *     console.log('download complete: ' + entry.toURL());
 *   }, (error) => {
 *     // handle error
 *   });
 * }
 *
 * ```
 *
 * To store files in a different/publicly accessible directory, please refer to the following link
 * https://github.com/apache/cordova-plugin-file#where-to-store-files
 *
 * @interfaces
 * FileUploadOptions
 * FileUploadResult
 * FileTransferError
 * @classes
 * FileTransferObject
 */
export declare class FileTransfer extends IonicNativePlugin {
    /**
     * Error code rejected from upload with FileTransferError
     * Defined in FileTransferError.
     *      FILE_NOT_FOUND_ERR: 1   Return when file was not found
     *      INVALID_URL_ERR: 2,     Return when url was invalid
     *      CONNECTION_ERR: 3,      Return on connection error
     *      ABORT_ERR: 4,           Return on aborting
     *      NOT_MODIFIED_ERR: 5     Return on '304 Not Modified' HTTP response
     * @enum {number}
     */
    FileTransferErrorCode: {
        FILE_NOT_FOUND_ERR: number;
        INVALID_URL_ERR: number;
        CONNECTION_ERR: number;
        ABORT_ERR: number;
        NOT_MODIFIED_ERR: number;
    };
    /**
     * Creates a new FileTransfer object
     * @return {FileTransferObject}
     */
    create(): FileTransferObject;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<FileTransfer, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<FileTransfer>;
}
/**
 * @hidden
 */
export declare class FileTransferObject {
    private _objectInstance;
    constructor();
    /**
     * Sends a file to a server.
     *
     * @param {string} fileUrl  Filesystem URL representing the file on the device or a data URI. For backwards compatibility, this can also be the full path of the file on the device.
     * @param {string} url  URL of the server to receive the file, as encoded by encodeURI().
     * @param {FileUploadOptions} [options]  Optional parameters.
     * @param {boolean} [trustAllHosts]  Optional parameter, defaults to false. If set to true, it accepts all security certificates. This is useful since Android rejects self-signed security certificates. Not recommended for production use. Supported on Android and iOS.
     * @returns {Promise<FileUploadResult>} Returns a Promise that resolves to a FileUploadResult and rejects with FileTransferError.
     */
    upload(fileUrl: string, url: string, options?: FileUploadOptions, trustAllHosts?: boolean): Promise<FileUploadResult>;
    /**
     * Downloads a file from server.
     *
     * @param {string} source  URL of the server to download the file, as encoded by encodeURI().
     * @param {string} target  Filesystem url representing the file on the device. For backwards compatibility, this can also be the full path of the file on the device.
     * @param {boolean} [trustAllHosts]  Optional parameter, defaults to false. If set to true, it accepts all security certificates. This is useful because Android rejects self-signed security certificates. Not recommended for production use. Supported on Android and iOS.
     * @param {object} [Optional] parameters, currently only supports headers (such as Authorization (Basic Authentication), etc).
     * @returns {Promise<any>} Returns a Promise that resolves to a FileEntry object.
     */
    download(source: string, target: string, trustAllHosts?: boolean, options?: {
        [s: string]: any;
    }): Promise<any>;
    /**
     * Registers a listener that gets called whenever a new chunk of data is transferred.
     * @param {Function} listener Listener that takes a progress event.
     */
    onProgress(listener: (event: ProgressEvent) => any): void;
    /**
     * Aborts an in-progress transfer. The onerror callback is passed a FileTransferError
     * object which has an error code of FileTransferError.ABORT_ERR.
     */
    abort(): void;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZXMiOlsiaW5kZXguZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElvbmljTmF0aXZlUGx1Z2luIH0gZnJvbSAnQGlvbmljLW5hdGl2ZS9jb3JlJztcbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVVwbG9hZE9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmb3JtIGVsZW1lbnQuXG4gICAgICogRGVmYXVsdHMgdG8gJ2ZpbGUnLlxuICAgICAqL1xuICAgIGZpbGVLZXk/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgbmFtZSB0byB1c2Ugd2hlbiBzYXZpbmcgdGhlIGZpbGUgb24gdGhlIHNlcnZlci5cbiAgICAgKiBEZWZhdWx0cyB0byAnaW1hZ2UuanBnJy5cbiAgICAgKi9cbiAgICBmaWxlTmFtZT86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIC0gZWl0aGVyIFBVVCBvciBQT1NULlxuICAgICAqIERlZmF1bHRzIHRvIFBPU1QuXG4gICAgICovXG4gICAgaHR0cE1ldGhvZD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgbWltZSB0eXBlIG9mIHRoZSBkYXRhIHRvIHVwbG9hZC5cbiAgICAgKiBEZWZhdWx0cyB0byBpbWFnZS9qcGVnLlxuICAgICAqL1xuICAgIG1pbWVUeXBlPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIG9wdGlvbmFsIGtleS92YWx1ZSBwYWlycyB0byBwYXNzIGluIHRoZSBIVFRQIHJlcXVlc3QuXG4gICAgICovXG4gICAgcGFyYW1zPzoge1xuICAgICAgICBbczogc3RyaW5nXTogYW55O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byB1cGxvYWQgdGhlIGRhdGEgaW4gY2h1bmtlZCBzdHJlYW1pbmcgbW9kZS5cbiAgICAgKiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAqL1xuICAgIGNodW5rZWRNb2RlPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBoZWFkZXIgbmFtZS9oZWFkZXIgdmFsdWVzLiBVc2UgYW4gYXJyYXkgdG8gc3BlY2lmeSBtb3JlXG4gICAgICogdGhhbiBvbmUgdmFsdWUuIE9uIGlPUywgRmlyZU9TLCBhbmQgQW5kcm9pZCwgaWYgYSBoZWFkZXIgbmFtZWRcbiAgICAgKiBDb250ZW50LVR5cGUgaXMgcHJlc2VudCwgbXVsdGlwYXJ0IGZvcm0gZGF0YSB3aWxsIE5PVCBiZSB1c2VkLlxuICAgICAqL1xuICAgIGhlYWRlcnM/OiB7XG4gICAgICAgIFtzOiBzdHJpbmddOiBhbnk7XG4gICAgfTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVVwbG9hZFJlc3VsdCB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBieXRlcyBzZW50IHRvIHRoZSBzZXJ2ZXIgYXMgcGFydCBvZiB0aGUgdXBsb2FkLlxuICAgICAqL1xuICAgIGJ5dGVzU2VudDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBIVFRQIHJlc3BvbnNlIGNvZGUgcmV0dXJuZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICByZXNwb25zZUNvZGU6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgSFRUUCByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIHJlc3BvbnNlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVycyBieSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIGhlYWRlcnM6IHtcbiAgICAgICAgW3M6IHN0cmluZ106IGFueTtcbiAgICB9O1xufVxuZXhwb3J0IGludGVyZmFjZSBGaWxlVHJhbnNmZXJFcnJvciB7XG4gICAgLyoqXG4gICAgICogT25lIG9mIHRoZSBwcmVkZWZpbmVkIGVycm9yIGNvZGVzIGxpc3RlZCBiZWxvdy5cbiAgICAgKi9cbiAgICBjb2RlOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVVJMIHRvIHRoZSBzb3VyY2UuXG4gICAgICovXG4gICAgc291cmNlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVVJMIHRvIHRoZSB0YXJnZXQuXG4gICAgICovXG4gICAgdGFyZ2V0OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogSFRUUCBzdGF0dXMgY29kZS4gVGhpcyBhdHRyaWJ1dGUgaXMgb25seSBhdmFpbGFibGUgd2hlbiBhIHJlc3BvbnNlXG4gICAgICogY29kZSBpcyByZWNlaXZlZCBmcm9tIHRoZSBIVFRQIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgaHR0cF9zdGF0dXM6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBSZXNwb25zZSBib2R5LiBUaGlzIGF0dHJpYnV0ZSBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIGEgcmVzcG9uc2UgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgSFRUUCBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGJvZHk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBFaXRoZXIgZS5nZXRNZXNzYWdlIG9yIGUudG9TdHJpbmcuXG4gICAgICovXG4gICAgZXhjZXB0aW9uOiBzdHJpbmc7XG59XG4vKipcbiAqIEBuYW1lIEZpbGUgVHJhbnNmZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgcGx1Z2luIGFsbG93cyB5b3UgdG8gdXBsb2FkIGFuZCBkb3dubG9hZCBmaWxlcy5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogVGhpcyBwbHVnaW4gaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBYSFIyXG4gKiBodHRwczovL2NvcmRvdmEuYXBhY2hlLm9yZy9ibG9nLzIwMTcvMTAvMTgvZnJvbS1maWxldHJhbnNmZXItdG8teGhyMi5odG1sXG4gKlxuICogQHVzYWdlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBGaWxlVHJhbnNmZXIsIEZpbGVVcGxvYWRPcHRpb25zLCBGaWxlVHJhbnNmZXJPYmplY3QgfSBmcm9tICdAaW9uaWMtbmF0aXZlL2ZpbGUtdHJhbnNmZXIvbmd4JztcbiAqIGltcG9ydCB7IEZpbGUgfSBmcm9tICdAaW9uaWMtbmF0aXZlL2ZpbGUnO1xuICpcbiAqIGNvbnN0cnVjdG9yKHByaXZhdGUgdHJhbnNmZXI6IEZpbGVUcmFuc2ZlciwgcHJpdmF0ZSBmaWxlOiBGaWxlKSB7IH1cbiAqXG4gKiAuLi5cbiAqXG4gKiBjb25zdCBmaWxlVHJhbnNmZXI6IEZpbGVUcmFuc2Zlck9iamVjdCA9IHRoaXMudHJhbnNmZXIuY3JlYXRlKCk7XG4gKlxuICogLy8gVXBsb2FkIGEgZmlsZTpcbiAqIGZpbGVUcmFuc2Zlci51cGxvYWQoLi4pLnRoZW4oLi4pLmNhdGNoKC4uKTtcbiAqXG4gKiAvLyBEb3dubG9hZCBhIGZpbGU6XG4gKiBmaWxlVHJhbnNmZXIuZG93bmxvYWQoLi4pLnRoZW4oLi4pLmNhdGNoKC4uKTtcbiAqXG4gKiAvLyBBYm9ydCBhY3RpdmUgdHJhbnNmZXI6XG4gKiBmaWxlVHJhbnNmZXIuYWJvcnQoKTtcbiAqXG4gKiAvLyBmdWxsIGV4YW1wbGVcbiAqIHVwbG9hZCgpIHtcbiAqICAgbGV0IG9wdGlvbnM6IEZpbGVVcGxvYWRPcHRpb25zID0ge1xuICogICAgICBmaWxlS2V5OiAnZmlsZScsXG4gKiAgICAgIGZpbGVOYW1lOiAnbmFtZS5qcGcnLFxuICogICAgICBoZWFkZXJzOiB7fVxuICogICAgICAuLi4uLlxuICogICB9XG4gKlxuICogICBmaWxlVHJhbnNmZXIudXBsb2FkKCc8ZmlsZSBwYXRoPicsICc8YXBpIGVuZHBvaW50PicsIG9wdGlvbnMpXG4gKiAgICAudGhlbigoZGF0YSkgPT4ge1xuICogICAgICAvLyBzdWNjZXNzXG4gKiAgICB9LCAoZXJyKSA9PiB7XG4gKiAgICAgIC8vIGVycm9yXG4gKiAgICB9KVxuICogfVxuICpcbiAqIGRvd25sb2FkKCkge1xuICogICBjb25zdCB1cmwgPSAnaHR0cDovL3d3dy5leGFtcGxlLmNvbS9maWxlLnBkZic7XG4gKiAgIGZpbGVUcmFuc2Zlci5kb3dubG9hZCh1cmwsIHRoaXMuZmlsZS5kYXRhRGlyZWN0b3J5ICsgJ2ZpbGUucGRmJykudGhlbigoZW50cnkpID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygnZG93bmxvYWQgY29tcGxldGU6ICcgKyBlbnRyeS50b1VSTCgpKTtcbiAqICAgfSwgKGVycm9yKSA9PiB7XG4gKiAgICAgLy8gaGFuZGxlIGVycm9yXG4gKiAgIH0pO1xuICogfVxuICpcbiAqIGBgYFxuICpcbiAqIFRvIHN0b3JlIGZpbGVzIGluIGEgZGlmZmVyZW50L3B1YmxpY2x5IGFjY2Vzc2libGUgZGlyZWN0b3J5LCBwbGVhc2UgcmVmZXIgdG8gdGhlIGZvbGxvd2luZyBsaW5rXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXBhY2hlL2NvcmRvdmEtcGx1Z2luLWZpbGUjd2hlcmUtdG8tc3RvcmUtZmlsZXNcbiAqXG4gKiBAaW50ZXJmYWNlc1xuICogRmlsZVVwbG9hZE9wdGlvbnNcbiAqIEZpbGVVcGxvYWRSZXN1bHRcbiAqIEZpbGVUcmFuc2ZlckVycm9yXG4gKiBAY2xhc3Nlc1xuICogRmlsZVRyYW5zZmVyT2JqZWN0XG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEZpbGVUcmFuc2ZlciBleHRlbmRzIElvbmljTmF0aXZlUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIHJlamVjdGVkIGZyb20gdXBsb2FkIHdpdGggRmlsZVRyYW5zZmVyRXJyb3JcbiAgICAgKiBEZWZpbmVkIGluIEZpbGVUcmFuc2ZlckVycm9yLlxuICAgICAqICAgICAgRklMRV9OT1RfRk9VTkRfRVJSOiAxICAgUmV0dXJuIHdoZW4gZmlsZSB3YXMgbm90IGZvdW5kXG4gICAgICogICAgICBJTlZBTElEX1VSTF9FUlI6IDIsICAgICBSZXR1cm4gd2hlbiB1cmwgd2FzIGludmFsaWRcbiAgICAgKiAgICAgIENPTk5FQ1RJT05fRVJSOiAzLCAgICAgIFJldHVybiBvbiBjb25uZWN0aW9uIGVycm9yXG4gICAgICogICAgICBBQk9SVF9FUlI6IDQsICAgICAgICAgICBSZXR1cm4gb24gYWJvcnRpbmdcbiAgICAgKiAgICAgIE5PVF9NT0RJRklFRF9FUlI6IDUgICAgIFJldHVybiBvbiAnMzA0IE5vdCBNb2RpZmllZCcgSFRUUCByZXNwb25zZVxuICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICovXG4gICAgRmlsZVRyYW5zZmVyRXJyb3JDb2RlOiB7XG4gICAgICAgIEZJTEVfTk9UX0ZPVU5EX0VSUjogbnVtYmVyO1xuICAgICAgICBJTlZBTElEX1VSTF9FUlI6IG51bWJlcjtcbiAgICAgICAgQ09OTkVDVElPTl9FUlI6IG51bWJlcjtcbiAgICAgICAgQUJPUlRfRVJSOiBudW1iZXI7XG4gICAgICAgIE5PVF9NT0RJRklFRF9FUlI6IG51bWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRmlsZVRyYW5zZmVyIG9iamVjdFxuICAgICAqIEByZXR1cm4ge0ZpbGVUcmFuc2Zlck9iamVjdH1cbiAgICAgKi9cbiAgICBjcmVhdGUoKTogRmlsZVRyYW5zZmVyT2JqZWN0O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEZpbGVUcmFuc2Zlck9iamVjdCB7XG4gICAgcHJpdmF0ZSBfb2JqZWN0SW5zdGFuY2U7XG4gICAgY29uc3RydWN0b3IoKTtcbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGZpbGUgdG8gYSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVVybCAgRmlsZXN5c3RlbSBVUkwgcmVwcmVzZW50aW5nIHRoZSBmaWxlIG9uIHRoZSBkZXZpY2Ugb3IgYSBkYXRhIFVSSS4gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB0aGlzIGNhbiBhbHNvIGJlIHRoZSBmdWxsIHBhdGggb2YgdGhlIGZpbGUgb24gdGhlIGRldmljZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICBVUkwgb2YgdGhlIHNlcnZlciB0byByZWNlaXZlIHRoZSBmaWxlLCBhcyBlbmNvZGVkIGJ5IGVuY29kZVVSSSgpLlxuICAgICAqIEBwYXJhbSB7RmlsZVVwbG9hZE9wdGlvbnN9IFtvcHRpb25zXSAgT3B0aW9uYWwgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt0cnVzdEFsbEhvc3RzXSAgT3B0aW9uYWwgcGFyYW1ldGVyLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgc2V0IHRvIHRydWUsIGl0IGFjY2VwdHMgYWxsIHNlY3VyaXR5IGNlcnRpZmljYXRlcy4gVGhpcyBpcyB1c2VmdWwgc2luY2UgQW5kcm9pZCByZWplY3RzIHNlbGYtc2lnbmVkIHNlY3VyaXR5IGNlcnRpZmljYXRlcy4gTm90IHJlY29tbWVuZGVkIGZvciBwcm9kdWN0aW9uIHVzZS4gU3VwcG9ydGVkIG9uIEFuZHJvaWQgYW5kIGlPUy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlVXBsb2FkUmVzdWx0Pn0gUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZpbGVVcGxvYWRSZXN1bHQgYW5kIHJlamVjdHMgd2l0aCBGaWxlVHJhbnNmZXJFcnJvci5cbiAgICAgKi9cbiAgICB1cGxvYWQoZmlsZVVybDogc3RyaW5nLCB1cmw6IHN0cmluZywgb3B0aW9ucz86IEZpbGVVcGxvYWRPcHRpb25zLCB0cnVzdEFsbEhvc3RzPzogYm9vbGVhbik6IFByb21pc2U8RmlsZVVwbG9hZFJlc3VsdD47XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgZmlsZSBmcm9tIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgIFVSTCBvZiB0aGUgc2VydmVyIHRvIGRvd25sb2FkIHRoZSBmaWxlLCBhcyBlbmNvZGVkIGJ5IGVuY29kZVVSSSgpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXQgIEZpbGVzeXN0ZW0gdXJsIHJlcHJlc2VudGluZyB0aGUgZmlsZSBvbiB0aGUgZGV2aWNlLiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHRoaXMgY2FuIGFsc28gYmUgdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZSBvbiB0aGUgZGV2aWNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RydXN0QWxsSG9zdHNdICBPcHRpb25hbCBwYXJhbWV0ZXIsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBzZXQgdG8gdHJ1ZSwgaXQgYWNjZXB0cyBhbGwgc2VjdXJpdHkgY2VydGlmaWNhdGVzLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIEFuZHJvaWQgcmVqZWN0cyBzZWxmLXNpZ25lZCBzZWN1cml0eSBjZXJ0aWZpY2F0ZXMuIE5vdCByZWNvbW1lbmRlZCBmb3IgcHJvZHVjdGlvbiB1c2UuIFN1cHBvcnRlZCBvbiBBbmRyb2lkIGFuZCBpT1MuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtPcHRpb25hbF0gcGFyYW1ldGVycywgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgaGVhZGVycyAoc3VjaCBhcyBBdXRob3JpemF0aW9uIChCYXNpYyBBdXRoZW50aWNhdGlvbiksIGV0YykuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZpbGVFbnRyeSBvYmplY3QuXG4gICAgICovXG4gICAgZG93bmxvYWQoc291cmNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nLCB0cnVzdEFsbEhvc3RzPzogYm9vbGVhbiwgb3B0aW9ucz86IHtcbiAgICAgICAgW3M6IHN0cmluZ106IGFueTtcbiAgICB9KTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbmV2ZXIgYSBuZXcgY2h1bmsgb2YgZGF0YSBpcyB0cmFuc2ZlcnJlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lciB0aGF0IHRha2VzIGEgcHJvZ3Jlc3MgZXZlbnQuXG4gICAgICovXG4gICAgb25Qcm9ncmVzcyhsaXN0ZW5lcjogKGV2ZW50OiBQcm9ncmVzc0V2ZW50KSA9PiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEFib3J0cyBhbiBpbi1wcm9ncmVzcyB0cmFuc2Zlci4gVGhlIG9uZXJyb3IgY2FsbGJhY2sgaXMgcGFzc2VkIGEgRmlsZVRyYW5zZmVyRXJyb3JcbiAgICAgKiBvYmplY3Qgd2hpY2ggaGFzIGFuIGVycm9yIGNvZGUgb2YgRmlsZVRyYW5zZmVyRXJyb3IuQUJPUlRfRVJSLlxuICAgICAqL1xuICAgIGFib3J0KCk6IHZvaWQ7XG59XG4iXX0=