import { IonicNativePlugin } from '@ionic-native/core';
import * as ɵngcc0 from '@angular/core';
interface FontOptions {
    name: string;
    size: number;
    italic: boolean;
    bold: boolean;
    align: 'left' | 'right' | 'center' | 'justified';
    color: string;
}
interface HeaderFooterLabelOptions {
    text: string;
    top: string;
    right: string;
    left: string;
    bottom: string;
    font: FontOptions;
    showPageIndex: boolean;
}
export interface PrintOptions {
    /**
     * The name of the print job and the document
     */
    name?: string;
    /**
     * The number of copies for the print task.
     * Only supported on iOS, Windows
     */
    copies?: number;
    /**
     * Limits the pages to print even the document contains more.
     * To skip the last n pages you can assign a negative value on iOS.
     * Only supported on iOS, Android
     */
    pageCount?: number;
    /**
     * Specifies the duplex mode to use for the print job.
     * Either double-sided on short site (duplex:'short'),
     * double-sided on long site (duplex:'long') or single-sided (duplex:'none').
     */
    duplex?: boolean;
    /**
     * The orientation of the printed content, portrait or landscape
     * Portrait by default.
     */
    orientation?: 'landscape' | 'portrait';
    /**
     * If your application only prints black text, setting this property to true can result in better performance in many cases.
     * False by default.
     */
    monochrome?: boolean;
    /**
     * If your application only prints black text, setting this property to true can result in better performance in many cases.
     * False by default.
     * Only supported on iOS, Windows
     */
    photo?: boolean;
    /**
     * Set to false to disable downscaling the image to fit into the content aread.
     * Only supported on Android
     */
    autoFit?: boolean;
    /**
     * The network URL to the printer.
     * Only supported on iOS
     */
    printer?: string;
    /**
     * Defines the maximum size of the content area.
     * Only supported on iOS
     */
    maxHeight?: string;
    /**
     * Defines the maximum size of the content area.
     * Only supported on iOS
     */
    maxWidth?: string;
    /**
     * Set to false to avoid margins.
     * The margins for each printed page. Each printer might have its own minimum margins depends on media type and paper format.
     */
    margin?: boolean | {
        top?: string;
        left?: string;
        right?: string;
        bottom?: string;
    };
    ui?: {
        hideNumberOfCopies?: string;
        hidePaperFormat?: string;
        top?: number;
        left?: number;
        height?: number;
        width?: number;
    };
    paper?: {
        width: string;
        height: string;
        name: string;
        length: string;
    };
    font?: FontOptions;
    header?: {
        height: string;
        labels: string[];
        label: HeaderFooterLabelOptions;
    };
    footer?: {
        height: string;
        labels: string[];
        label: HeaderFooterLabelOptions;
    };
}
/**
 * @name Printer
 * @description Prints documents or HTML rendered content
 * @usage
 * ```typescript
 * import { Printer, PrintOptions } from '@ionic-native/printer/ngx';
 *
 * constructor(private printer: Printer) { }
 *
 * ...
 *
 * this.printer.isAvailable().then(onSuccess, onError);
 *
 * let options: PrintOptions = {
 *      name: 'MyDocument',
 *      duplex: true,
 *      orientation: 'landscape',
 *      monochrome: true
 * }
 *
 * this.printer.print(content, options).then(onSuccess, onError);
 * ```
 * @interfaces
 * PrintOptions
 */
export declare class Printer extends IonicNativePlugin {
    /**
     * Checks whether the device is capable of printing (uses `check()` internally)
     * @returns {Promise<boolean>}
     */
    isAvailable(): Promise<boolean>;
    /**
     * Checks To check if printing is supported in general
     * @return {Promise<any>} returns a promise that resolve with an object indicating whether printing is available
     */
    check(): Promise<any>;
    /**
     * Displays a system interface allowing the user to select an available printer. To speak with a printer directly you need to know the network address by picking them before via `printer.pick`.
     * @returns {Promise<any>}
     */
    pick(): Promise<any>;
    /**
     * Sends content to the printer.
     * @param content {string | HTMLElement} The content to print. Can be a URL or an HTML string. If a HTML DOM Object is provided, its innerHtml property value will be used.
     * @param options {PrintOptions} optional. The options to pass to the printer
     * @returns {Promise<any>}
     */
    print(content?: string | HTMLElement, options?: PrintOptions): Promise<any>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Printer, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<Printer>;
}
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZXMiOlsiaW5kZXguZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJb25pY05hdGl2ZVBsdWdpbiB9IGZyb20gJ0Bpb25pYy1uYXRpdmUvY29yZSc7XG5pbnRlcmZhY2UgRm9udE9wdGlvbnMge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBzaXplOiBudW1iZXI7XG4gICAgaXRhbGljOiBib29sZWFuO1xuICAgIGJvbGQ6IGJvb2xlYW47XG4gICAgYWxpZ246ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZpZWQnO1xuICAgIGNvbG9yOiBzdHJpbmc7XG59XG5pbnRlcmZhY2UgSGVhZGVyRm9vdGVyTGFiZWxPcHRpb25zIHtcbiAgICB0ZXh0OiBzdHJpbmc7XG4gICAgdG9wOiBzdHJpbmc7XG4gICAgcmlnaHQ6IHN0cmluZztcbiAgICBsZWZ0OiBzdHJpbmc7XG4gICAgYm90dG9tOiBzdHJpbmc7XG4gICAgZm9udDogRm9udE9wdGlvbnM7XG4gICAgc2hvd1BhZ2VJbmRleDogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgUHJpbnRPcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJpbnQgam9iIGFuZCB0aGUgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBuYW1lPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgY29waWVzIGZvciB0aGUgcHJpbnQgdGFzay5cbiAgICAgKiBPbmx5IHN1cHBvcnRlZCBvbiBpT1MsIFdpbmRvd3NcbiAgICAgKi9cbiAgICBjb3BpZXM/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogTGltaXRzIHRoZSBwYWdlcyB0byBwcmludCBldmVuIHRoZSBkb2N1bWVudCBjb250YWlucyBtb3JlLlxuICAgICAqIFRvIHNraXAgdGhlIGxhc3QgbiBwYWdlcyB5b3UgY2FuIGFzc2lnbiBhIG5lZ2F0aXZlIHZhbHVlIG9uIGlPUy5cbiAgICAgKiBPbmx5IHN1cHBvcnRlZCBvbiBpT1MsIEFuZHJvaWRcbiAgICAgKi9cbiAgICBwYWdlQ291bnQ/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBkdXBsZXggbW9kZSB0byB1c2UgZm9yIHRoZSBwcmludCBqb2IuXG4gICAgICogRWl0aGVyIGRvdWJsZS1zaWRlZCBvbiBzaG9ydCBzaXRlIChkdXBsZXg6J3Nob3J0JyksXG4gICAgICogZG91YmxlLXNpZGVkIG9uIGxvbmcgc2l0ZSAoZHVwbGV4Oidsb25nJykgb3Igc2luZ2xlLXNpZGVkIChkdXBsZXg6J25vbmUnKS5cbiAgICAgKi9cbiAgICBkdXBsZXg/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcHJpbnRlZCBjb250ZW50LCBwb3J0cmFpdCBvciBsYW5kc2NhcGVcbiAgICAgKiBQb3J0cmFpdCBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIG9yaWVudGF0aW9uPzogJ2xhbmRzY2FwZScgfCAncG9ydHJhaXQnO1xuICAgIC8qKlxuICAgICAqIElmIHlvdXIgYXBwbGljYXRpb24gb25seSBwcmludHMgYmxhY2sgdGV4dCwgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIHRydWUgY2FuIHJlc3VsdCBpbiBiZXR0ZXIgcGVyZm9ybWFuY2UgaW4gbWFueSBjYXNlcy5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIG1vbm9jaHJvbWU/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIElmIHlvdXIgYXBwbGljYXRpb24gb25seSBwcmludHMgYmxhY2sgdGV4dCwgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIHRydWUgY2FuIHJlc3VsdCBpbiBiZXR0ZXIgcGVyZm9ybWFuY2UgaW4gbWFueSBjYXNlcy5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqIE9ubHkgc3VwcG9ydGVkIG9uIGlPUywgV2luZG93c1xuICAgICAqL1xuICAgIHBob3RvPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBkb3duc2NhbGluZyB0aGUgaW1hZ2UgdG8gZml0IGludG8gdGhlIGNvbnRlbnQgYXJlYWQuXG4gICAgICogT25seSBzdXBwb3J0ZWQgb24gQW5kcm9pZFxuICAgICAqL1xuICAgIGF1dG9GaXQ/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBuZXR3b3JrIFVSTCB0byB0aGUgcHJpbnRlci5cbiAgICAgKiBPbmx5IHN1cHBvcnRlZCBvbiBpT1NcbiAgICAgKi9cbiAgICBwcmludGVyPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgY29udGVudCBhcmVhLlxuICAgICAqIE9ubHkgc3VwcG9ydGVkIG9uIGlPU1xuICAgICAqL1xuICAgIG1heEhlaWdodD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIGNvbnRlbnQgYXJlYS5cbiAgICAgKiBPbmx5IHN1cHBvcnRlZCBvbiBpT1NcbiAgICAgKi9cbiAgICBtYXhXaWR0aD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTZXQgdG8gZmFsc2UgdG8gYXZvaWQgbWFyZ2lucy5cbiAgICAgKiBUaGUgbWFyZ2lucyBmb3IgZWFjaCBwcmludGVkIHBhZ2UuIEVhY2ggcHJpbnRlciBtaWdodCBoYXZlIGl0cyBvd24gbWluaW11bSBtYXJnaW5zIGRlcGVuZHMgb24gbWVkaWEgdHlwZSBhbmQgcGFwZXIgZm9ybWF0LlxuICAgICAqL1xuICAgIG1hcmdpbj86IGJvb2xlYW4gfCB7XG4gICAgICAgIHRvcD86IHN0cmluZztcbiAgICAgICAgbGVmdD86IHN0cmluZztcbiAgICAgICAgcmlnaHQ/OiBzdHJpbmc7XG4gICAgICAgIGJvdHRvbT86IHN0cmluZztcbiAgICB9O1xuICAgIHVpPzoge1xuICAgICAgICBoaWRlTnVtYmVyT2ZDb3BpZXM/OiBzdHJpbmc7XG4gICAgICAgIGhpZGVQYXBlckZvcm1hdD86IHN0cmluZztcbiAgICAgICAgdG9wPzogbnVtYmVyO1xuICAgICAgICBsZWZ0PzogbnVtYmVyO1xuICAgICAgICBoZWlnaHQ/OiBudW1iZXI7XG4gICAgICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIH07XG4gICAgcGFwZXI/OiB7XG4gICAgICAgIHdpZHRoOiBzdHJpbmc7XG4gICAgICAgIGhlaWdodDogc3RyaW5nO1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIGxlbmd0aDogc3RyaW5nO1xuICAgIH07XG4gICAgZm9udD86IEZvbnRPcHRpb25zO1xuICAgIGhlYWRlcj86IHtcbiAgICAgICAgaGVpZ2h0OiBzdHJpbmc7XG4gICAgICAgIGxhYmVsczogc3RyaW5nW107XG4gICAgICAgIGxhYmVsOiBIZWFkZXJGb290ZXJMYWJlbE9wdGlvbnM7XG4gICAgfTtcbiAgICBmb290ZXI/OiB7XG4gICAgICAgIGhlaWdodDogc3RyaW5nO1xuICAgICAgICBsYWJlbHM6IHN0cmluZ1tdO1xuICAgICAgICBsYWJlbDogSGVhZGVyRm9vdGVyTGFiZWxPcHRpb25zO1xuICAgIH07XG59XG4vKipcbiAqIEBuYW1lIFByaW50ZXJcbiAqIEBkZXNjcmlwdGlvbiBQcmludHMgZG9jdW1lbnRzIG9yIEhUTUwgcmVuZGVyZWQgY29udGVudFxuICogQHVzYWdlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBQcmludGVyLCBQcmludE9wdGlvbnMgfSBmcm9tICdAaW9uaWMtbmF0aXZlL3ByaW50ZXIvbmd4JztcbiAqXG4gKiBjb25zdHJ1Y3Rvcihwcml2YXRlIHByaW50ZXI6IFByaW50ZXIpIHsgfVxuICpcbiAqIC4uLlxuICpcbiAqIHRoaXMucHJpbnRlci5pc0F2YWlsYWJsZSgpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAqXG4gKiBsZXQgb3B0aW9uczogUHJpbnRPcHRpb25zID0ge1xuICogICAgICBuYW1lOiAnTXlEb2N1bWVudCcsXG4gKiAgICAgIGR1cGxleDogdHJ1ZSxcbiAqICAgICAgb3JpZW50YXRpb246ICdsYW5kc2NhcGUnLFxuICogICAgICBtb25vY2hyb21lOiB0cnVlXG4gKiB9XG4gKlxuICogdGhpcy5wcmludGVyLnByaW50KGNvbnRlbnQsIG9wdGlvbnMpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAqIGBgYFxuICogQGludGVyZmFjZXNcbiAqIFByaW50T3B0aW9uc1xuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBQcmludGVyIGV4dGVuZHMgSW9uaWNOYXRpdmVQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgY2FwYWJsZSBvZiBwcmludGluZyAodXNlcyBgY2hlY2soKWAgaW50ZXJuYWxseSlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICBpc0F2YWlsYWJsZSgpOiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBUbyBjaGVjayBpZiBwcmludGluZyBpcyBzdXBwb3J0ZWQgaW4gZ2VuZXJhbFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn0gcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlIHdpdGggYW4gb2JqZWN0IGluZGljYXRpbmcgd2hldGhlciBwcmludGluZyBpcyBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBjaGVjaygpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgYSBzeXN0ZW0gaW50ZXJmYWNlIGFsbG93aW5nIHRoZSB1c2VyIHRvIHNlbGVjdCBhbiBhdmFpbGFibGUgcHJpbnRlci4gVG8gc3BlYWsgd2l0aCBhIHByaW50ZXIgZGlyZWN0bHkgeW91IG5lZWQgdG8ga25vdyB0aGUgbmV0d29yayBhZGRyZXNzIGJ5IHBpY2tpbmcgdGhlbSBiZWZvcmUgdmlhIGBwcmludGVyLnBpY2tgLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcGljaygpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2VuZHMgY29udGVudCB0byB0aGUgcHJpbnRlci5cbiAgICAgKiBAcGFyYW0gY29udGVudCB7c3RyaW5nIHwgSFRNTEVsZW1lbnR9IFRoZSBjb250ZW50IHRvIHByaW50LiBDYW4gYmUgYSBVUkwgb3IgYW4gSFRNTCBzdHJpbmcuIElmIGEgSFRNTCBET00gT2JqZWN0IGlzIHByb3ZpZGVkLCBpdHMgaW5uZXJIdG1sIHByb3BlcnR5IHZhbHVlIHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7UHJpbnRPcHRpb25zfSBvcHRpb25hbC4gVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcHJpbnRlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgcHJpbnQoY29udGVudD86IHN0cmluZyB8IEhUTUxFbGVtZW50LCBvcHRpb25zPzogUHJpbnRPcHRpb25zKTogUHJvbWlzZTxhbnk+O1xufVxuZXhwb3J0IHt9O1xuIl19